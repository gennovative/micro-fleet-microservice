{"version":3,"sources":["app/adapters/MessageBrokerAdapter.ts"],"names":[],"mappings":"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","file":"MessageBrokerAdapter.js","sourcesContent":["import { EventEmitter } from 'events';\r\n\r\nimport * as amqp from 'amqplib';\r\nimport * as uuid from 'uuid';\r\nimport * as _ from 'lodash';\r\n\r\nimport { injectable, inject, CriticalException, MinorException, Guard } from 'back-lib-common-util';\r\n\r\nimport { IConfigurationProvider } from './ConfigurationProvider';\r\nimport { SettingKeys as S } from '../constants/SettingKeys';\r\nimport { Types as T } from '../constants/Types';\r\n\r\nexport type MessageHandleFunction = (msg: IMessage, ack?: () => void, nack?: () => void) => void;\r\nexport type RpcHandleFunction = (msg: IMessage, reply: (response: any) => void, deny?: () => void) => void;\r\n\r\ninterface IQueueInfo {\r\n\tname: string;\r\n\tmatchingPattern: string;\r\n}\r\n\r\nexport interface IMessage {\r\n\tdata: any;\r\n\traw: amqp.Message;\r\n\tproperties?: IPublishOptions;\r\n}\r\n\r\nexport interface IPublishOptions {\r\n\tcontentType?: string;\r\n\tcontentEncoding?: string;\r\n\tcorrelationId?: string;\r\n\treplyTo?: string;\r\n}\r\n\r\nexport interface IMessageBrokerAdapter extends IAdapter {\r\n\t/**\r\n\t * Sends `message` to the broker and label the message with `topic`.\r\n\t * @param {string} topic - A name to label the message with. Should be in format \"xxx.yyy.zzz\".\r\n\t * @param {string | Json | JsonArray} payload - A message to send to broker.\r\n\t * @param {IPublishOptions} options - Options to add to message properties.\r\n\t */\r\n\tpublish(topic: string, payload: string | Json | JsonArray, options?: IPublishOptions): Promise<void>;\r\n\r\n\t/**\r\n\t * Listens to messages whose label matches `matchingPattern`.\r\n\t * @param {string} matchingPattern - Pattern to match with message label. Should be in format \"xx.*\" or \"xx.#.#\".\r\n\t * @param {function} onMessage - Callback to invoke when there is an incomming message.\r\n\t * @return {string} - A promise with resolve to a consumer tag, which is used to unsubscribe later.\r\n\t */\r\n\tsubscribe(matchingPattern: string, onMessage: MessageHandleFunction, noAck?: boolean): Promise<string>;\r\n\r\n\t/**\r\n\t * Stop listening to a subscription that was made before.\r\n\t */\r\n\tunsubscribe(consumerTag: string): Promise<void>;\r\n\r\n\tonError(handler: Function): void;\r\n}\r\n\r\n@injectable()\r\nexport class TopicMessageBrokerAdapter implements IMessageBrokerAdapter {\r\n\t\r\n\tprivate _connectionPrm: Promise<amqp.Connection>;\r\n\t\r\n\t// Each microservice has 2 channels, one for consuming and the other for publishing.\r\n\tprivate _publishChanPrm: Promise<amqp.Channel>;\r\n\tprivate _consumeChanPrm: Promise<amqp.Channel>;\r\n\r\n\tprivate _exchange: string;\r\n\tprivate _queue: string;\r\n\tprivate _subscriptions: Map<string, Set<string>>;\r\n\tprivate _emitter: EventEmitter;\r\n\r\n\tconstructor(\r\n\t\t@inject(T.CONFIG_PROVIDER) private _configProvider: IConfigurationProvider\r\n\t) {\r\n\t\tthis._subscriptions = new Map();\r\n\t\tthis._emitter = new EventEmitter();\r\n\t}\r\n\t\r\n\tpublic init(): Promise<void> {\r\n\t\tlet cfgAdt = this._configProvider;\r\n\t\tthis._exchange = cfgAdt.get(S.MSG_BROKER_EXCHANGE);\r\n\t\tthis._queue = cfgAdt.get(S.MSG_BROKER_QUEUE);\r\n\r\n\t\tlet host = cfgAdt.get(S.MSG_BROKER_HOST),\r\n\t\t\tusername = cfgAdt.get(S.MSG_BROKER_USERNAME),\r\n\t\t\tpassword = cfgAdt.get(S.MSG_BROKER_PASSWORD);\r\n\t\treturn <any>this.connect(host, username, password);\r\n\t}\r\n\r\n\tpublic dispose(): Promise<void> {\r\n\t\treturn this.disconnect().then(() => {\r\n\t\t\tthis._connectionPrm = null;\r\n\t\t\tthis._publishChanPrm = null;\r\n\t\t\tthis._consumeChanPrm = null;\r\n\t\t});\r\n\t}\r\n\r\n\tpublic async subscribe(matchingPattern: string, onMessage: MessageHandleFunction, noAck?: boolean): Promise<string> {\r\n\t\tGuard.assertNotEmpty('matchingPattern', matchingPattern);\r\n\t\tGuard.assertIsFunction('onMessage', onMessage);\r\n\t\ttry {\r\n\t\t\tlet channelPromise = this._consumeChanPrm;\r\n\t\t\tif (!channelPromise) {\r\n\t\t\t\t// Create a new consuming channel if there is not already, and from now on we listen to this only channel.\r\n\t\t\t\tchannelPromise = this._consumeChanPrm = this.createChannel();\r\n\t\t\t}\r\n\r\n\t\t\tlet ch = await channelPromise;\r\n\r\n\t\t\t// The consuming channel should bind to only one queue, but that queue can be routed with multiple keys.\r\n\t\t\tlet queueName = await this.bindQueue(channelPromise, matchingPattern);\r\n\r\n\t\t\tlet conResult = await ch.consume(queueName,\r\n\t\t\t\t(msg: amqp.Message) => {\r\n\t\t\t\t\tlet ack = () => ch.ack(msg),\r\n\t\t\t\t\t\tnack = () => ch.nack(msg);\r\n\r\n\t\t\t\t\tonMessage(this.parseMessage(msg), ack, nack);\r\n\t\t\t\t}, \r\n\t\t\t\t{noAck: (noAck === undefined ? true : noAck)}\r\n\t\t\t);\r\n\t\t\tthis.moreSub(matchingPattern, conResult.consumerTag);\r\n\t\t\treturn conResult.consumerTag;\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Subscription error');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic async publish(topic: string, payload: string | Json | JsonArray, options?: IPublishOptions): Promise<void> {\r\n\t\tGuard.assertNotEmpty('topic', topic);\r\n\t\tGuard.assertNotEmpty('message', payload);\r\n\t\ttry {\r\n\t\t\tif (!this._publishChanPrm) {\r\n\t\t\t\t// Create a new publishing channel if there is not already, and from now on we publish to this only channel.\r\n\t\t\t\tthis._publishChanPrm = this.createChannel();\r\n\t\t\t}\r\n\t\t\tlet ch: amqp.Channel = await this._publishChanPrm,\r\n\t\t\t\topt: amqp.Options.Publish;\r\n\t\t\tlet [msg, opts] = this.buildMessage(payload, options);\r\n\r\n\t\t\t// We publish to exchange, then the exchange will route to appropriate consuming queue.\r\n\t\t\tch.publish(this._exchange, topic, msg, opts);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Publishing error');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic async unsubscribe(consumerTag: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tif (!this._consumeChanPrm) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet ch = await this._consumeChanPrm;\r\n\r\n\t\t\t// onMessage callback will never be called again.\r\n\t\t\tawait ch.cancel(consumerTag);\r\n\t\t\t\r\n\t\t\tlet unusedPattern = this.lessSub(consumerTag);\r\n\t\t\tif (unusedPattern) {\r\n\t\t\t\tthis.unbindQueue(this._consumeChanPrm, unusedPattern);\r\n\t\t\t}\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Unsubscription error');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic onError(handler: Function): void {\r\n\t\tthis._emitter.on('error', handler);\r\n\t}\r\n\r\n\r\n\tprivate connect(hostAddress: string, username: string, password: string): Promise<amqp.Connection> {\r\n\t\tlet credentials = '';\r\n\t\t\r\n\t\t// Output:\r\n\t\t// - \"usr@pass\"\r\n\t\t// - \"@pass\"\r\n\t\t// - \"usr@\"\r\n\t\t// - \"\"\r\n\t\tif (!_.isEmpty(username) || !_.isEmpty(password)) {\r\n\t\t\tcredentials = `${username || ''}:${password || ''}@`;\r\n\t\t}\r\n\r\n\t\t// URI format: amqp://usr:pass@10.1.2.3/vhost\r\n\t\treturn this._connectionPrm = <any>amqp.connect(`amqp://${credentials}${hostAddress}`)\r\n\t\t\t.then((conn: amqp.Connection) => {\r\n\t\t\t\tconn.on('error', (err) => {\r\n\t\t\t\t\tthis._emitter.emit('error', err);\r\n\t\t\t\t});\r\n\t\t\t\treturn conn;\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\treturn this.handleError(err, 'Connection creation error');\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate async disconnect(): Promise<void> {\r\n\t\ttry {\r\n\t\t\tif (!this._connectionPrm || !this._consumeChanPrm) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet ch: amqp.Channel,\r\n\t\t\t\tpromises = [];\r\n\r\n\t\t\tif (this._consumeChanPrm) {\r\n\t\t\t\tch = await this._consumeChanPrm;\r\n\t\t\t\t// Close consuming channel\r\n\t\t\t\tpromises.push(ch.close());\r\n\t\t\t}\r\n\r\n\t\t\tif (this._publishChanPrm) {\r\n\t\t\t\tch = await this._publishChanPrm;\r\n\t\t\t\t// Close publishing channel\r\n\t\t\t\tpromises.push(ch.close());\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure all channels are closed before we close connection.\r\n\t\t\t// Otherwise we will have dangling channels until application shuts down.\r\n\t\t\tawait Promise.all(promises);\r\n\r\n\t\t\tif (this._connectionPrm) {\r\n\t\t\t\tlet conn: amqp.Connection = await this._connectionPrm;\r\n\t\t\t\t// Close connection, causing all temp queues to be deleted.\r\n\t\t\t\treturn conn.close();\r\n\t\t\t}\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Connection closing error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async createChannel(): Promise<amqp.Channel> {\r\n\t\tconst EXCHANGE_TYPE = 'topic';\r\n\r\n\t\ttry {\r\n\t\t\tlet conn = await this._connectionPrm,\r\n\t\t\t\tch = await conn.createChannel(),\r\n\r\n\t\t\t\t// Tell message broker to create an exchange with this name if there's not any already.\r\n\t\t\t\t// Setting exchange as \"durable\" means the exchange with same name will be re-created after the message broker restarts,\r\n\t\t\t\t// but all queues and waiting messages will be lost.\r\n\t\t\t\texResult = await ch.assertExchange(this._exchange, EXCHANGE_TYPE, {durable: true});\r\n\r\n\t\t\tch['queue'] = '';\r\n\t\t\tch.on('error', (err) => {\r\n\t\t\t\tthis._emitter.emit('error', err);\r\n\t\t\t});\r\n\t\t\treturn ch;\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Channel creation error');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If `queueName` is null, creates a queue and binds it to `matchingPattern`.\r\n\t * If `queueName` is not null, binds `matchingPattern` to the queue with that name.\r\n\t * @return {string} null if no queue is created, otherwise returns the new queue name.\r\n\t */\r\n\tprivate async bindQueue(channelPromise: Promise<amqp.Channel>, matchingPattern: string): Promise<string> {\r\n\t\ttry {\r\n\t\t\tlet ch = await channelPromise,\r\n\t\t\t\tisTempQueue = (!this._queue),\r\n\t\t\t\t// If configuration doesn't provide queue name,\r\n\t\t\t\t// we provide empty string as queue name to tell message broker to choose a unique name for us.\r\n\t\t\t\t// Setting queue as \"exclusive\" to delete the temp queue when connection closes.\r\n\t\t\t\tquResult = await ch.assertQueue(this._queue || '', {exclusive: isTempQueue});\r\n\r\n\t\t\tawait ch.bindQueue(quResult.queue, this._exchange, matchingPattern);\r\n\r\n\t\t\t// Store queue name for later use.\r\n\t\t\t// In our system, each channel is associated with only one queue.\r\n\t\t\treturn ch['queue'] = quResult.queue;\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Queue binding error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async unbindQueue(channelPromise: Promise<amqp.Channel>, matchingPattern: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tlet ch = await channelPromise,\r\n\t\t\t\tqueueName = ch['queue'];\r\n\r\n\t\t\tawait ch.unbindQueue(queueName, this._exchange, matchingPattern);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Queue unbinding error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate handleError(err, message: string): Promise<never> {\r\n\t\tif (err instanceof CriticalException) {\r\n\t\t\t// If this is already a wrapped exception.\r\n\t\t\treturn Promise.reject(err);\r\n\t\t}\r\n\t\treturn Promise.reject(new CriticalException(`${message}: ${err}`));\r\n\t}\r\n\t\r\n\tprivate moreSub(matchingPattern: string, consumerTag: string): void {\r\n\t\tlet consumers: Set<string> = this._subscriptions.get(matchingPattern);\r\n\r\n\t\tif (!consumers) {\r\n\t\t\tthis._subscriptions.set(matchingPattern, new Set(consumerTag));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsumers.add(consumerTag);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {string} the pattern name which should be unbound, othewise return null.\r\n\t */\r\n\tprivate lessSub(consumerTag: string): string {\r\n\t\tlet subscriptions = this._subscriptions,\r\n\t\t\tmatchingPattern = null;\r\n\t\t\r\n\t\tfor (let sub of subscriptions) {\r\n\t\t\tif (!sub[1].has(consumerTag)) { continue; }\r\n\r\n\t\t\t// Remove this tag from consumer list.\r\n\t\t\tsub[1].delete(consumerTag);\r\n\t\t\t\r\n\t\t\t// If consumer list becomes empty.\r\n\t\t\tif (!sub[1].size) {\r\n\t\t\t\t// Mark this pattern as unused and should be unbound.\r\n\t\t\t\tmatchingPattern = sub[0];\r\n\t\t\t\tsubscriptions.delete(matchingPattern);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn matchingPattern;\r\n\t}\r\n\r\n\tprivate buildMessage(payload: string | Json | JsonArray, options?: IPublishOptions): Array<any> {\r\n\t\tlet msg: string;\r\n\t\toptions = options || {};\r\n\r\n\t\tif (_.isString(payload)) {\r\n\t\t\tmsg = payload;\r\n\t\t\toptions.contentType = 'text/plain';\r\n\t\t} else {\r\n\t\t\tmsg = JSON.stringify(payload);\r\n\t\t\toptions.contentType = 'application/json';\r\n\t\t}\r\n\r\n\t\treturn [Buffer.from(msg), options];\r\n\t}\r\n\r\n\tprivate parseMessage(raw: amqp.Message): IMessage {\r\n\t\tlet msg: Partial<IMessage> = {\r\n\t\t\traw,\r\n\t\t\tproperties: raw.properties || {}\r\n\t\t};\r\n\r\n\t\tif (msg.properties.contentType == 'text/plain') {\r\n\t\t\tmsg.data = raw.content.toString(msg.properties.contentEncoding);\r\n\t\t} else {\r\n\t\t\tmsg.data = JSON.parse(<any>raw.content);\r\n\t\t}\r\n\r\n\t\treturn <IMessage>msg;\r\n\t}\r\n}"]}