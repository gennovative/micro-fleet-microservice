{"version":3,"sources":["app/adapters/MessageBrokerAdapter.ts"],"names":[],"mappings":"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","file":"MessageBrokerAdapter.js","sourcesContent":["import { EventEmitter } from 'events';\r\nimport * as amqp from 'amqplib';\r\nimport * as uuid from 'uuid';\r\n\r\nimport { IAdapter } from './IAdapter';\r\nimport { IConfigurationAdapter } from './ConfigurationAdapter';\r\nimport { CriticalException, MinorException } from '../microservice/Exceptions';\r\nimport { injectable, inject } from '../utils/DependencyContainer';\r\nimport { Guard } from '../utils/Guard';\r\nimport { SettingKeys as S } from '../constants/SettingKeys';\r\nimport { Types as T } from '../constants/Types';\r\n\r\nexport type MessageHandler = (msg: IMessage, ack: Function, nack: Function) => void;\r\n\r\ninterface IQueueInfo {\r\n\tname: string;\r\n\tmatchingPattern: string;\r\n}\r\n\r\nexport interface IMessage {\r\n\tdata: any;\r\n\traw: amqp.Message;\r\n\tcorrelationId?: string;\r\n}\r\n\r\nexport interface IPublishOptions extends amqp.Options.Publish {\r\n\r\n}\r\n\r\nexport interface IMessageBrokerAdapter extends IAdapter {\r\n\t/**\r\n\t * Sends `message` to the broker and label the message with `topic`.\r\n\t * @param {string} topic - A name to label the message with. Should be in format \"xxx.yyy.zzz\".\r\n\t * @param {any} message - A message to send to broker.\r\n\t */\r\n\tpublish(topic: string, message: any): Promise<void>;\r\n\r\n\t/**\r\n\t * Listens to messages whose label matches `matchingPattern`.\r\n\t * @param {string} matchingPattern - Pattern to match with message label. Should be in format \"xx.*\" or \"xx.#.#\".\r\n\t * @param {function} onMessage - Callback to invoke when there is an incomming message.\r\n\t * @return {string} - A promise with resolve to a consumer tag, which is used to unsubscribe later.\r\n\t */\r\n\tsubscribe(matchingPattern: string, onMessage: MessageHandler): Promise<string>;\r\n\r\n\t/**\r\n\t * Stop listening to a subscription that was made before.\r\n\t */\r\n\tunsubscribe(consumerTag: string): Promise<void>;\r\n}\r\n\r\n@injectable()\r\nexport class TopicMessageBrokerAdapter implements IMessageBrokerAdapter {\r\n\t\r\n\tprivate _connectionPrm: Promise<amqp.Connection>;\r\n\t\r\n\t// Each microservice has 2 channels, one for consuming and the other for publishing.\r\n\tprivate _publishChanPrm: Promise<amqp.Channel>;\r\n\tprivate _consumeChanPrm: Promise<amqp.Channel>;\r\n\r\n\tprivate _exchange: string;\r\n\tprivate _subscriptions: Map<string, Set<string>>;\r\n\r\n\tconstructor(\r\n\t\t@inject(T.CONFIG_ADAPTER) private _configAdapter: IConfigurationAdapter\r\n\t) {\r\n\t\tthis._subscriptions = new Map();\r\n\t}\r\n\t\r\n\tpublic init(): Promise<void> {\r\n\t\tlet cfgAdt = this._configAdapter;\r\n\r\n\t\tthis._exchange = cfgAdt.get(S.MSG_BROKER_EXCHANGE);\r\n\t\tthis.connect(cfgAdt.get(S.MSG_BROKER_HOST));\r\n\t\t/*\r\n\t\tthis.connect({\r\n\t\t\thost: cfgAdt.get(S.MSG_BROKER_HOST),\r\n\t\t\texchange: cfgAdt.get(S.MSG_BROKER_EXCHANGE),\r\n\t\t\treconnectTimeout: cfgAdt.get(S.MSG_BROKER_RECONN_TIMEOUT)\r\n\t\t});\r\n\t\t//*/\r\n\t\treturn Promise.resolve();\r\n\t}\r\n\r\n\tpublic async dispose(): Promise<void> {\r\n\t\tthis.disconnect();\r\n\t\tthis._connectionPrm = null;\r\n\t\tthis._publishChanPrm = null;\r\n\t\tthis._consumeChanPrm = null;\r\n\t}\r\n\r\n\tpublic async subscribe(matchingPattern: string, onMessage: MessageHandler, noAck?: boolean): Promise<string> {\r\n\t\tGuard.assertNotEmpty('matchingPattern', matchingPattern);\r\n\t\tGuard.assertIsFunction('onMessage', onMessage);\r\n\t\ttry {\r\n\t\t\tlet channelPromise = this._consumeChanPrm;\r\n\t\t\tif (!channelPromise) {\r\n\t\t\t\t// Create a new consuming channel if there is not already, and from now on we listen to this only channel.\r\n\t\t\t\tchannelPromise = this._consumeChanPrm = this.createChannel();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet ch = await channelPromise;\r\n\t\t\t\t\r\n\t\t\t// The consuming channel should bind to only one queue, but that queue can be routed with multiple keys.\r\n\t\t\tawait this.bindQueue(channelPromise, matchingPattern);\r\n\r\n\t\t\tlet conResult = await ch.consume(null, \r\n\t\t\t\t(msg: amqp.Message) => {\r\n\t\t\t\t\tlet ack = () => ch.ack(msg),\r\n\t\t\t\t\t\tnack = () => ch.nack(msg);\r\n\r\n\t\t\t\t\tonMessage(this.parseMessage(msg), ack, nack);\r\n\t\t\t\t}, \r\n\t\t\t\t{noAck: noAck || false}\r\n\t\t\t);\r\n\t\t\tthis.moreSub(matchingPattern, conResult.consumerTag);\r\n\t\t\treturn conResult.consumerTag;\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Subscription error');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic async publish(topic: string, message: any, options?: IPublishOptions): Promise<void> {\r\n\t\tGuard.assertNotEmpty('topic', topic);\r\n\t\tGuard.assertNotEmpty('message', message);\r\n\t\ttry {\r\n\t\t\tif (!this._publishChanPrm) {\r\n\t\t\t\t// Create a new publishing channel if there is not already, and from now on we publish to this only channel.\r\n\t\t\t\tthis._publishChanPrm = this.createChannel();\r\n\t\t\t}\r\n\t\t\tlet ch = await this._publishChanPrm;\r\n\r\n\t\t\t// We publish to exchange, then the exchange will route to appropriate consuming queue.\r\n\t\t\tch.publish(this._exchange, topic, new Buffer(message), options);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Publishing error');\r\n\t\t}\r\n\t}\r\n\r\n\tpublic rpc(requestTopic: string, responseTopic: string, message: any): Promise<IMessage> {\r\n\t\treturn new Promise<IMessage>((resolve, reject) => {\r\n\t\t\t// There are many requests to same `requestTopic` and they listen to same `responseTopic`,\r\n\t\t\t// A request only carea for a response with same `correlationId`.\r\n\t\t\tconst correlationId = uuid.v4();\r\n\r\n\t\t\tlet conCh = this._consumeChanPrm,\r\n\t\t\t\tresEmitter = conCh['responseEmitter'];\r\n\t\t\t\r\n\t\t\tthis.subscribe(responseTopic, (msg: IMessage, ack: Function, nack: Function) => {\r\n\t\t\t\t// Announce that we've got a message with this correlationId.\r\n\t\t\t\tresEmitter.emit(msg.correlationId, msg);\r\n\t\t\t})\r\n\t\t\t.then(consumerTag => {\r\n\t\t\t\tresEmitter.once(correlationId, msg => {\r\n\t\t\t\t\t// We got what we want, stop consuming.\r\n\t\t\t\t\tthis.unsubscribe(consumerTag);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Resolve only when we get the response with matched correlationId.\r\n\t\t\t\t\tresolve(msg);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Send request, marking the message with correlationId.\r\n\t\t\t\treturn this.publish(requestTopic, message, { correlationId });\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\treject(new MinorException(`RPC error: ${err}`));\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tpublic async unsubscribe(consumerTag: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tif (!this._consumeChanPrm) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet ch = await this._consumeChanPrm;\r\n\r\n\t\t\t// onMessage callback will never be called again.\r\n\t\t\tawait ch.cancel(consumerTag);\r\n\t\t\t\r\n\t\t\tlet unusedPattern = this.lessSub(consumerTag);\r\n\t\t\tif (unusedPattern) {\r\n\t\t\t\tthis.unbindQueue(this._consumeChanPrm, unusedPattern);\r\n\t\t\t}\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Unsubscription error');\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprivate connect(hostAddress: string): Promise<amqp.Connection> {\r\n\t\treturn this._connectionPrm = <any>amqp.connect(`amqp://${hostAddress}`)\r\n\t\t\t.catch(err => {\r\n\t\t\t\treturn this.handleError(err, 'Connection creation error');\r\n\t\t\t});\r\n\t}\r\n\r\n\tprivate async disconnect() {\r\n\t\ttry {\r\n\t\t\tif (!this._connectionPrm || !this._consumeChanPrm) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet ch: amqp.Channel,\r\n\t\t\t\tpromises = [];\r\n\r\n\t\t\tif (this._consumeChanPrm) {\r\n\t\t\t\tlet queueName = ch['queue'];\r\n\r\n\t\t\t\tch = await this._consumeChanPrm;\r\n\r\n\t\t\t\t// Destroy the queue, any waiting messages will be re-routed to another queue by the exchange.\r\n\t\t\t\tpromises.push(ch.deleteQueue(queueName));\r\n\r\n\t\t\t\t// Close consuming channel\r\n\t\t\t\tpromises.push(ch.close());\r\n\t\t\t}\r\n\r\n\t\t\tif (this._publishChanPrm) {\r\n\t\t\t\tch = await this._publishChanPrm;\r\n\t\t\t\t// Close publishing channel\r\n\t\t\t\tpromises.push(ch.close());\r\n\t\t\t}\r\n\r\n\t\t\tif (this._connectionPrm) {\r\n\t\t\t\tlet conn: amqp.Connection = await this._connectionPrm;\r\n\t\t\t\t// Close connection\r\n\t\t\t\tpromises.push(conn.close());\r\n\t\t\t}\r\n\r\n\t\t\tawait Promise.all(promises);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Connection closing error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async createChannel(): Promise<amqp.Channel> {\r\n\t\tconst EXCHANGE_TYPE = 'topic';\r\n\r\n\t\ttry {\r\n\t\t\tlet conn = await this._connectionPrm,\r\n\t\t\t\tch = await conn.createChannel(),\r\n\r\n\t\t\t\t// Tell message broker to create an exchange with this name if there's not any already.\r\n\t\t\t\t// Setting exchange as \"durable\" means the exchange with same name will be re-created after the message broker restarts,\r\n\t\t\t\t// but all queues and waiting messages will be lost.\r\n\t\t\t\texResult = await ch.assertExchange(this._exchange, EXCHANGE_TYPE, {durable: true});\r\n\r\n\t\t\tch['queue'] = {};\r\n\t\t\tch['responseEmitter'] = new EventEmitter();\r\n\t\t\tch['responseEmitter'].setMaxListeners(0);\r\n\t\t\treturn Promise.resolve(ch);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Channel creation error');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If `queueName` is null, creates a queue and binds it to `matchingPattern`.\r\n\t * If `queueName` is not null, binds `matchingPattern` to the queue with that name.\r\n\t * @return {string} null if no queue is created, otherwise returns the new queue name.\r\n\t */\r\n\tprivate async bindQueue(channelPromise: Promise<amqp.Channel>, matchingPattern: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tlet ch = await channelPromise,\r\n\t\t\t\tqueueName = ch['queue'],\r\n\t\t\t\t\r\n\t\t\t\t// Provide empty string as queue name to tell message broker to choose a unique name for us.\r\n\t\t\t\t// Setting queue as \"exclusive\" to delete the queue when connection closes.\r\n\t\t\t\tquResult = await ch.assertQueue(queueName || '', {exclusive: true});\r\n\r\n\t\t\tawait ch.bindQueue(quResult.queue, this._exchange, matchingPattern);\r\n\r\n\t\t\t// Store queue name for later use.\r\n\t\t\t// In our system, each channel is associated with only one queue.\r\n\t\t\tch['queue'] = quResult.queue;\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Queue binding error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async unbindQueue(channelPromise: Promise<amqp.Channel>, matchingPattern: string): Promise<void> {\r\n\t\ttry {\r\n\t\t\tlet ch = await channelPromise,\r\n\t\t\t\tqueueName = ch['queue'];\r\n\r\n\t\t\tawait ch.unbindQueue(queueName, this._exchange, matchingPattern);\r\n\r\n\t\t} catch (err) {\r\n\t\t\treturn this.handleError(err, 'Queue unbinding error');\r\n\t\t}\r\n\t}\r\n\r\n\tprivate handleError(err, message: string): Promise<never> {\r\n\t\tif (err instanceof CriticalException) {\r\n\t\t\t// If this is already a wrapped exception.\r\n\t\t\treturn Promise.reject(err);\r\n\t\t}\r\n\t\treturn Promise.reject(new CriticalException(`${message}: ${err}`));\r\n\t}\r\n\t\r\n\tprivate moreSub(matchingPattern: string, consumerTag: string): void {\r\n\t\tlet consumers: Set<string> = this._subscriptions.get(matchingPattern);\r\n\r\n\t\tif (!consumers) {\r\n\t\t\tthis._subscriptions.set(matchingPattern, new Set(consumerTag));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsumers.add(consumerTag);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {string} the pattern name which should be unbound, othewise return null.\r\n\t */\r\n\tprivate lessSub(consumerTag: string): string {\r\n\t\tlet subscriptions = this._subscriptions,\r\n\t\t\tmatchingPattern = null;\r\n\t\t\r\n\t\tfor (let sub of subscriptions) {\r\n\t\t\tif (!sub[1].has(consumerTag)) { continue; }\r\n\r\n\t\t\t// Remove this tag from consumer list.\r\n\t\t\tsub[1].delete(consumerTag);\r\n\t\t\t\r\n\t\t\t// If consumer list becomes empty.\r\n\t\t\tif (!sub[1].size) {\r\n\t\t\t\t// Mark this pattern as unused and should be unbound.\r\n\t\t\t\tmatchingPattern = sub[0];\r\n\t\t\t\tsubscriptions.delete(matchingPattern);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn matchingPattern;\r\n\t}\r\n\r\n\tprivate parseMessage(raw: amqp.Message): IMessage {\r\n\t\treturn {\r\n\t\t\traw,\r\n\t\t\tdata: JSON.parse(raw.content.toJSON().data.toString()),\r\n\t\t\tcorrelationId: raw.properties.correlationId\r\n\t\t};\r\n\t}\r\n}"]}