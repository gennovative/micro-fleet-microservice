{"version":3,"sources":["app/rpc/MessageBrokerRpcCaller.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,mCAAsC;AAEtC,6BAA6B;AAE7B,iDAAiD;AACjD,0CAAuC;AACvC,8CAAgD;AAChD,sEAAwF;AAExF,mDAA4D;AAK5D,IAAa,sBAAsB,GAAnC,4BACG,SAAQ,6BAAa;IAGvB,YACmC,aAAoC;QAEtE,KAAK,EAAE,CAAC;QAF0B,kBAAa,GAAb,aAAa,CAAuB;IAGvE,CAAC;IAED,IAAI,CAAC,UAAkB,EAAE,MAAc,EAAE,KAAU;QAClD,aAAK,CAAC,aAAa,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;QAC9C,aAAK,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAEtC,MAAM,CAAC,IAAI,OAAO,CAAe,CAAC,OAAO,EAAE,MAAM;YAChD,0FAA0F;YAC1F,iEAAiE;YACjE,MAAM,aAAa,GAAG,IAAI,CAAC,EAAE,EAAE,CAAC;YAEhC,IAAI,OAAO,GAAG,IAAI,qBAAY,EAAE,CAAC;YAEjC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,YAAY,UAAU,IAAI,MAAM,EAAE,EAAE,CAAC,GAAa,EAAE,GAAa,EAAE,IAAe;gBAC9G,IAAI,UAAU,GAAG,WAAW,CAAC;oBAC5B,4DAA4D;oBAC5D,6DAA6D;oBAC7D,4BAA4B;oBAC5B,EAAE,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;wBACzD,aAAa,CAAC,UAAU,CAAC,CAAC;wBAC1B,UAAU,GAAG,IAAI,CAAC;wBAElB,6DAA6D;wBAC7D,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;wBAChD,OAAO,GAAG,IAAI,CAAC;oBAChB,CAAC;gBACF,CAAC,EAAE,GAAG,CAAC,CAAC;YACT,CAAC,CAAC;iBACD,IAAI,CAAC,WAAW;gBAChB,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,GAAa;oBACzC,uCAAuC;oBACvC,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;oBAC5C,OAAO,CAAe,GAAG,CAAC,IAAI,CAAC,CAAC;gBACjC,CAAC,CAAC,CAAC;gBAEH,IAAI,OAAO,GAAgB;oBAC1B,IAAI,EAAE,IAAI,CAAC,KAAK;oBAChB,EAAE,EAAE,UAAU;oBACd,KAAK;iBACL,CAAC;gBAEF,wDAAwD;gBACxD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,WAAW,UAAU,IAAI,MAAM,EAAE,EAAE,OAAO,EAAE,EAAE,aAAa,EAAE,CAAC,CAAC;YAClG,CAAC,CAAC;iBACD,KAAK,CAAC,GAAG;gBACT,MAAM,CAAC,IAAI,EAAE,CAAC,cAAc,CAAC,cAAc,GAAG,EAAE,CAAC,CAAC,CAAC;YACpD,CAAC,CAAC,CAAC;QACJ,CAAC,CAAC,CAAC;IACJ,CAAC;CACD,CAAA;AAzDY,sBAAsB;IADlC,gCAAU,EAAE;IAMV,WAAA,4BAAM,CAAC,aAAC,CAAC,cAAc,CAAC,CAAA;;GALd,sBAAsB,CAyDlC;AAzDY,wDAAsB","file":"MessageBrokerRpcCaller.js","sourcesContent":["import { EventEmitter } from 'events';\r\n\r\nimport * as uuid from 'uuid';\r\n\r\nimport * as ex from '../microservice/Exceptions';\r\nimport { Guard } from '../utils/Guard';\r\nimport { Types as T } from '../constants/Types';\r\nimport { injectable, inject, IDependencyContainer } from '../utils/DependencyContainer';\r\nimport { IMessageBrokerAdapter, MessageHandleFunction, IMessage } from '../adapters/MessageBrokerAdapter';\r\nimport { RpcCallerBase, IRpcCaller } from './RpcCallerBase';\r\nimport { IRpcRequest, IRpcResponse } from './RpcModels';\r\n\r\n\r\n@injectable()\r\nexport class MessageBrokerRpcCaller\r\n\t\t\textends RpcCallerBase\r\n\t\t\timplements IRpcCaller {\r\n\r\n\tconstructor(\r\n\t\t@inject(T.BROKER_ADAPTER) private _msgBrokerAdt: IMessageBrokerAdapter\r\n\t) {\r\n\t\tsuper();\r\n\t}\r\n\r\n\tcall(moduleName: string, action: string, param: any): Promise<IRpcResponse> {\r\n\t\tGuard.assertDefined('moduleName', moduleName);\r\n\t\tGuard.assertDefined('action', action);\r\n\r\n\t\treturn new Promise<IRpcResponse>((resolve, reject) => {\r\n\t\t\t// There are many requests to same `requestTopic` and they listen to same `responseTopic`,\r\n\t\t\t// A request only carea for a response with same `correlationId`.\r\n\t\t\tconst correlationId = uuid.v4();\r\n\r\n\t\t\tlet emitter = new EventEmitter();\r\n\r\n\t\t\tthis._msgBrokerAdt.subscribe(`response.${moduleName}.${action}`, (msg: IMessage, ack: Function, nack?: Function) => {\r\n\t\t\t\tlet intervalId = setInterval(() => {\r\n\t\t\t\t\t// There are chances that the message comes before the below\r\n\t\t\t\t\t// `emitter.once` runs. So let's make sure we only emit event\r\n\t\t\t\t\t// when there is a listener.\r\n\t\t\t\t\tif (emitter.listenerCount(msg.properties.correlationId)) {\r\n\t\t\t\t\t\tclearInterval(intervalId);\r\n\t\t\t\t\t\tintervalId = null;\r\n\r\n\t\t\t\t\t\t// Announce that we've got a message with this correlationId.\r\n\t\t\t\t\t\temitter.emit(msg.properties.correlationId, msg);\r\n\t\t\t\t\t\temitter = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 100);\r\n\t\t\t})\r\n\t\t\t.then(consumerTag => {\r\n\t\t\t\temitter.once(correlationId, (msg: IMessage) => {\r\n\t\t\t\t\t// We got what we want, stop consuming.\r\n\t\t\t\t\tthis._msgBrokerAdt.unsubscribe(consumerTag);\r\n\t\t\t\t\tresolve(<IRpcResponse>msg.data);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet request: IRpcRequest = {\r\n\t\t\t\t\tfrom: this._name,\r\n\t\t\t\t\tto: moduleName,\r\n\t\t\t\t\tparam\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Send request, marking the message with correlationId.\r\n\t\t\t\treturn this._msgBrokerAdt.publish(`request.${moduleName}.${action}`, request, { correlationId });\r\n\t\t\t})\r\n\t\t\t.catch(err => {\r\n\t\t\t\treject(new ex.MinorException(`RPC error: ${err}`));\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n}"]}